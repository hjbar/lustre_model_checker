node Delay1(x : int; init : int) returns (y : int);
let
  y = init -> pre x;
tel

node Delay3(x : int; init0 : int; init1 : int; init2 : int) returns (y : int);
var d1, d2 : int;
let
  d1 = Delay1(x, init0);
  d2 = Delay1(d1, init1);
  y  = Delay1(d2, init2);
tel

node AccumReset(x : int; reset : bool) returns (s : int);
let
  s = if reset then 0 else x + (0 -> pre s);
tel

node G(x : int; reset : bool) returns (y : int; ok : bool);
var s, x1, x3 : int;
let
  -- internal state machine 1
  s  = AccumReset(x, reset);

  -- internal state machine 2 (history)
  x1 = Delay1(x, 0);
  x3 = Delay3(x, 0, 0, 0);

  -- output depends on both state machines
  y  = if reset then 0 else (s + x1 - x3);

  -- ok is itself a stateful monitor (important!)
  ok = (not reset => (y = (s + x1 - x3))) and (true -> pre ok);
tel

node check(A : int; B : bool) returns (OK : bool);
var y1, y2, py1 : int; ok1, ok2 : bool;
let
  -- First instance of G: its state MUST be independent
  (y1, ok1) = G(A, B);

  -- A substream that must be treated as its own stream when inlining
  py1 = 0 -> pre y1;

  -- Second instance of G, fed with pre(y1)
  (y2, ok2) = G(py1, not ok1);

  -- Property: combines two automata + a history-based constraint
  OK =
    ok1 and ok2
    and ( (0 -> (0 -> (0 -> pre pre pre (if B then y1 else y2)))) <= (if B then y1 else y2) );
tel
